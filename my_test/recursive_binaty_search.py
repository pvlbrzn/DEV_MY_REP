import time
from random import randint


def time_logger(func):
    def inner(list, val, left, right):
        start_time = time.perf_counter()  # Используем более точный таймер
        res = func(list, val, left, right)
        end_time = time.perf_counter() - start_time
        print(f'Время работы функции = {end_time:.10f} секунд')  # Выводим с высокой точностью
        return res

    return inner


@time_logger
def recursive_binary_search(list, val, left, right):
    """Рекурсивный бинарный поиск"""
    # Базовый случай если число не найдено
    if left > right:
        return f'Число {val} не найдено в списке {list}'

    mid = (left + right) // 2
    # Базовый случай число найдено
    if list[mid] == val:
        return f'число {val} находится на позиции {mid}'
    elif list[mid] > val:
        return recursive_binary_search(list, val, left, mid - 1)
    else:
        return recursive_binary_search(list, val, mid + 1, right)


@time_logger
def binary_search(list, val, left, right):
    mid = (left + right) // 2
    while list[mid] != val:
        if val > list[mid]:
            left = mid + 1
        else:
            right = mid - 1
        mid = (left + right) // 2
        if left > right:
            break
    if val == list[mid]:
        return f'Число {val} находится в данном списке под индексом: {mid}'
    else:
        return 'В данном списке нет введенного вами числа =('


data = [randint(-1000, 10000) for _ in range(10000)]
data.sort()

print(recursive_binary_search(data, 100, 0, len(data) - 1))
print(binary_search(data, 1000, 0, len(data) - 1))

'''
Рекурсивный бинарный поиск медленнее итеративного по следующим причинам:
1. Накладные расходы на вызов функции.
В Python каждый вызов функции создает новый стек вызовов, что требует дополнительных операций:
Сохранение текущего состояния выполнения.
Передача аргументов функции.
Управление стеком вызовов.
В рекурсивной реализации для каждой итерации создается новый уровень стека, что увеличивает накладные расходы.

2. Ограничение глубины рекурсии
Python имеет ограничение на глубину рекурсии (по умолчанию около 1000). 
Для больших списков рекурсивный подход может вызвать переполнение стека (RecursionError), 
тогда как итеративный алгоритм не имеет таких ограничений.

3. Оптимизация кода интерпретатором
Итеративные алгоритмы проще для оптимизации на уровне компиляции или интерпретации, 
так как они не используют сложную механику вызовов функций.
В некоторых языках, таких как C или Java, рекурсия может быть оптимизирована компилятором 
(например, с использованием хвостовой рекурсии). 
Но Python не поддерживает оптимизацию хвостовой рекурсии, 
поэтому рекурсивный код всегда будет иметь больше накладных расходов.

4. Дополнительная работа с аргументами
В рекурсивном подходе значения аргументов (list, val, left, right) передаются на каждом уровне вызова. 
Это добавляет небольшие накладные расходы, особенно при работе с большими структурами данных.
В итеративном подходе такие накладные расходы отсутствуют, поскольку все операции выполняются в одном контексте.

Когда использовать рекурсию?
Рекурсивные алгоритмы удобны для задач, которые естественно разделяются на подзадачи 
(например, задачи на деревья или графы).
Однако для задач, которые можно легко решить итеративно, рекурсия менее предпочтительна из-за вышеуказанных причин.

Вывод:
Итеративный бинарный поиск быстрее из-за меньших накладных расходов на вызов функций 
и более эффективного использования ресурсов памяти и процессора.
'''
